#!/bin/bash

set_compiler_env()
{
    # refresh current environment
    local current_env="$CONDA_DEFAULT_ENV"
    conda deactivate
    conda activate "$current_env"

    # NOTE: the compiler options here are pulled straight from the Python Makefile
    if [[ $linux ]]; then
        export LDSHARED="$CC -shared"
    elif [[ $macos ]]; then
        export LDSHARED="$CC -bundle -undefined dynamic_lookup"
    fi
}

install_cross_compilers()
{
    if [[ -z $compilers_installed ]]; then
        echo "$info" "installing cross-compilers for pip packages..."
        
        # install cross compilers
        local pkgs=("$cc_pkg" "$cxx_pkg" "$gfortran_pkg")
        local pkg_diff="$(conda install --override-channels -c anaconda ${pkgs[@]} --no-update-deps --json --quiet)"
        local install_error="$(echo "$pkg_diff" | jq -r '.error')"
        if [[ $install_error != "null" ]]; then
            echo -e "$error" "$install_error"
            exit 1
        fi

        # filter out only packages than were added, NOT updated/downgraded
        local actions="$(echo "$pkg_diff" | jq '.actions')"
        [[ $actions != "null" ]] &&
            local link="$(echo "$actions" | jq '.LINK')"
        [[ $actions != "null" ]] &&
            local unlink="$(echo "$actions" | jq '.UNLINK')"
        [[ $link ]] && [[ $link != "null" ]] &&
            local add="$(echo "$link" | jq '[.[].name]')"
        [[ $unlink ]] && [[ $unlink != "null" ]] &&
            local sub="$(echo "$unlink" | jq '[.[].name]')"
        [[ $add ]] &&
            tmp_pkgs="$add"
        [[ $add ]] && [[ $sub ]] &&
            tmp_pkgs="$(echo "{\"add\": $add, \"sub\": $sub}" | jq '.add-.sub')"
        [[ $tmp_pkgs ]] &&
            tmp_pkgs="$(echo $tmp_pkgs | jq -r '.[]' | grep -v "^lib")"

        set_compiler_env
        compilers_installed=true
    fi
}

uninstall_cross_compilers()
{
    if [[ $compilers_installed ]] && [[ $tmp_pkgs ]]; then
        echo "$info" "uninstalling cross-compilers..."
        conda uninstall ${tmp_pkgs[@]} --yes $quiet
        unset compilers_installed
    fi
}

set_poetry_config()
{
    venvs_create="$(poetry config settings.virtualenvs.create)"  # <-- save previous value
    poetry config settings.virtualenvs.create "false"
}

restore_poetry_config()
{
    if [[ $venvs_create ]]; then
        poetry config settings.virtualenvs.create "$venvs_create"
        unset venvs_create
    fi
}

save_poetry_lockfile()
{
    if [[ -f "$poetry_dir/$poetry_lock" ]]; then
        cp "$poetry_dir/$poetry_lock" "$dep_dir"
        p_lockfile_saved=true
    fi
}

restore_poetry_lockfile()
{
    if [[ $p_lockfile_saved ]]; then
        cp "$dep_dir/$poetry_lock" "$poetry_dir"
    fi
}

exit_trap()
{
    exit_message
    restore_poetry_lockfile
    restore_poetry_config
}

usage()
{
    # NOTE: if you update this print message, please update README.md
    echo "$help" "usage: $script_name --name PROJECT --file FILE [--file FILE]..."
    echo "$s___" "       $s__________ [--poetry DIR] [--version VERSION] [--output DIR]"
    echo "$s___" "       $s__________ [--no-dev] [--unlock] [--force] [--no-color]"
    echo "$s___" "       $s__________ [--quiet] [--help]"
}

advanced_usage()
{
    # NOTE: if you update this print message, please update README.md
    usage
    echo "$s___"
    echo "$s___" "Package all dependencies into a portable conda environment tarball"
    echo "$s___"
    echo "$s___" "required arguments:"
    echo "$s___" "  --name, -n PROJECT        Name of the project to package. Will be used for"
    echo "$s___" "                            the name in the output file."
    echo "$s___" "  --file, -f FILE           Conda environment file. This option can be used"
    echo "$s___" "                            multiple times to specify multiple files. The"
    echo "$s___" "                            environment will be updated in the order that they"
    echo "$s___" "                            are given on the command line."
    echo "$s___"
    echo "$s___" "optional arguments:"
    echo "$s___" "  --poetry, -p DIR          Poetry project directory."
    echo "$s___" "  --version, -v VERSION     Version number to be included in output file name."
    echo "$s___" "  --output, -o DIR          Directory where the final tarball will go."
    echo "$s___" "                            Otherwise, tarball will be ouputed to the current"
    echo "$s___" "                            working directory."
    echo "$s___" "  --no-dev                  Do not install dev dependencies for Poetry."
    echo "$s___" "  --unlock                  Overwrite Poetry lockfile and update dependencies."
    echo "$s___" "  --force                   Overwrite any existing archive at the output path."
    echo "$s___" "  --no-color                Disable colored output."
    echo "$s___" "  --quiet, -q               Suppress output for commands."
    echo "$s___" "  --help, -h                Show this help message then exit."
}

opt_twice_err()
{
    echo "$error" "'$1' option cannot be used more than once"
    usage
    exit 1
}

files=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--name)
            [[ $name ]] && opt_twice_err "--name"
            name="$2"
            shift # past argument
            shift # past value
            ;;
        -f|--file)
            files+=("$2")
            shift # past argument
            shift # past value
            ;;
        -p|--poetry)
            [[ $poetry_dir ]] && opt_twice_err "--poetry"
            poetry_dir="$2"
            shift # past argument
            shift # past value
            ;;
        -v|--version)
            [[ $version ]] && opt_twice_err "--version"
            version="$2"
            shift # past argument
            shift # past value
            ;;
        -o|--output)
            [[ $output_dir ]] && opt_twice_err "--output"
            output_dir="$2"
            shift # past argument
            shift # past value
            ;;
        --no-dev)
            no_dev="$1"
            shift # past argument
            ;;
        --unlock)
            unlock=true
            shift # past argument
            ;;
        --force)
            force="$1"
            shift # past argument
            ;;
        --no-color)
            shift # past argument
            ;;
        -q|--quiet)
            quiet="$1"
            export PIP_QUIET=1
            shift # past argument
            ;;
        -h|--help)
            advanced_usage
            exit 0
            ;;
        *)
            echo "$error" "'$1' not a recognized option"
            usage
            exit 1
            ;;
    esac
done

# check for required options
if [[ -z $name ]]; then
    echo "$error" "'--name' option is required"
    usage
    exit 1
fi
if [[ ${#files[@]} -eq 0 ]]; then
    echo "$error" "'--file' option is required (atleast once)"
    usage
    exit 1
fi

# make sure environment files exist
for file in ${files[@]}; do
    if [[ ! -f $file ]]; then
        echo "$error" "'$file' is either not a file or it doesn't exist"
        usage
        exit 1
    fi
done

# set output file env
output_name="$name"
if [[ $version ]]; then
    if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then 
        echo "$warning" "'$version' does not match numerical format X.Y.Z"
    fi 
    output_name+="-$version"
fi
output_file="$output_name.tar.gz"

# set full output path
output="$output_file"
if [[ $output_dir ]]; then
    if [[ ! -d $output_dir ]]; then
        echo "$error" "'$output_dir' is not a directory or does not exist"
        exit 1
    fi 
    output="$output_dir/$output_file"
fi

# check if output already exists
if [[ -f $output || -d $output ]]; then
    if [[ -z $force ]]; then
        echo "$error" "output file '$output' already exists; use --force option to overwrite"
        exit 1
    fi
fi 

# exit as soon as a command fails and print error
trap exit_trap EXIT
set -e

conda_initiate

# set pip cache directory
set_pip_cache_dir
echo "$info" "using pip cache directory '$PIP_CACHE_DIR'"

remove_old_env

pip_count=0

# scan for pip dependencies
for file in ${files[@]}; do
    # warn user for pip dependencies
    if [[ $(cat "$file" | egrep "^\s*-\s+pip:\s*$" | wc -l) -gt 0 ]]; then
        echo "$warning" "found pip dependencies in '$file'; this is not recommended!"
        ((++pip_count))
    fi
done

# create and ENTER target environment
conda_env_create
conda activate "$env"

# remove 'defaults' for to enforce consistency
conda config --env --remove channels defaults

# install cross compilers to compile pip packages
if [[ $pip_count -gt 0 ]]; then
    install_cross_compilers
fi

# update the environment 
for file in ${files[@]}; do
    conda_env_update
done

# setup dependencies info output
dep_name="dependencies"
dep_dir="$CONDA_PREFIX/$dep_name"
dep_file="$output_name.yml"
poetry_lock="poetry.lock"
mkdir -p "$dep_dir"

# export environment to .yml file
uninstall_cross_compilers
echo "$info" "exporting pinned dependencies to '$dep_file'..."
conda env export | grep -v "^prefix: " | grep -v "^$" > "$dep_dir/$dep_file"

# install pip packages in target environment
if [[ $poetry_dir ]]; then
    poetry_install="${bold}[${green}poetry-install${reset}${bold}]${reset}"
    echo "$info" "Poetry project specified in '$poetry_dir': running $poetry_install..."

    # change logging for poetry_install
    set_logging "$default_tag $poetry_install"
   
    poetry_dir="$(readlink -e "$poetry_dir")"  # <-- set to absolute path
    install_cross_compilers
    set_poetry_config
    save_poetry_lockfile

    # TODO: remove this when Poetry is more capable (see README)
    # set Poetry environment to yield independent cache
    export XDG_CACHE_HOME="$CONDA_PREFIX/xdg_cache"

    # install pip packages
    echo "$info" "installing pip packages via Poetry..."
    cd "$poetry_dir"
    [[ $unlock ]] && rm -f "$poetry_lock"
    poetry install $no_dev $quiet $ansi $no_ansi
    save_poetry_lockfile
    cd -

    restore_poetry_config

    # TODO: remove this when Poetry is more capable (see README)
    # remove cache and revert environment
    rm -rf "$XDG_CACHE_HOME"
    unset XDG_CACHE_HOME

    uninstall_cross_compilers
    echo "$info" "Complete!"

    # revert logging back to default settings
    set_logging "$default_tag"
fi

# run conda-pack to package the environment
echo "$info" "packaging environment via conda-pack..."
conda pack -o "$output" --arcroot "$output_name" $force $quiet

# EXIT target environment
conda deactivate

output="$(readlink -e "$output")"  # <-- set to absolute path

# NOTE: if you update this print message, please update README.md
echo "$info" "Complete! Environment is now packaged in '$output'"
echo "$help" "[Instructions]"
echo "$s___"
echo "$s___" "  Initial Setup:"
echo "$s___" "    1. untar archive        --> tar -xf $output_file"
echo "$s___" "    2. activate environment --> source $output_name/bin/activate"
echo "$s___" "    3. fix path prefixes    --> conda unpack"
echo "$s___"
echo "$s___" "  Normal Use:"
echo "$s___" "    *  activate             --> source $output_name/bin/activate"
echo "$s___" "    *  deactivate           --> source deactivate"
echo "$s___"
echo "$s___" "  Info:"
echo "$s___" "    *  conda dependencies     @ $output_name/$dep_name/$dep_file"
echo "$s___" "    *  poetry lockfile        @ $output_name/$dep_name/$poetry_lock"
